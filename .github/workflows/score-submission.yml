name: Score Submission

on:
  pull_request_target:
    paths:
      - 'submissions/inbox/**'
  workflow_dispatch:

jobs:
  score:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: write

    steps:
      - name: Checkout code (base branch only)
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pandas scikit-learn torch torch-geometric

      # -------------------------------
      # Restore private test labels from secrets , 
      # decrept , store temprarly in data/test_labes.csv
      # -------------------------------
      - name: Restore private test labels
        env:
          TEST_LABELS_CSV_B64: ${{ secrets.TEST_LABELS_CSV_B64 }}
        run: |
          if [ -z "$TEST_LABELS_CSV_B64" ]; then
            echo "Missing TEST_LABELS_CSV_B64 secret"
            exit 1
          fi
          mkdir -p data
          echo "$TEST_LABELS_CSV_B64" | base64 -d > data/test_labels.csv

      - name: Find submission file (from PR)
        id: find_submission
        uses: actions/github-script@v6
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.setFailed("No pull request context available.");
              return;
            }
            const files = await github.paginate(
              github.rest.pulls.listFiles,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                per_page: 100,
              }
            );


            const predictionFile = files
              .map(f => f.filename)
              .find(name => name.startsWith("submissions/inbox/") && name.endsWith("/predictions.csv.gpg"));
            const metadataFile = files
              .map(f => f.filename)
              .find(name => name.startsWith("submissions/inbox/") && name.endsWith("/metadata.json"));

            if (!predictionFile || !metadataFile) {
              core.setFailed("Submission must include predictions.csv.gpg and metadata.json under submissions/inbox/<team>/<run_id>/");
              return;
            }

            const parts = predictionFile.split("/");
            if (parts.length < 5) {
              core.setFailed("Invalid submission path. Expected submissions/inbox/<team>/<run_id>/predictions.csv.gpg");
              return;
            }

            core.setOutput("prediction", predictionFile);
            core.setOutput("metadata", metadataFile);
            core.setOutput("head_repo", pr.head.repo.full_name);
            core.setOutput("head_sha", pr.head.sha);
            core.setOutput("submitter", pr.user.login);
            core.setOutput("pr_number", pr.number);
            core.setOutput("team", parts[2]);
            core.setOutput("run_id", parts[3]);

      - name: Download submission files (read-only)
        id: download_submission
        env:
          PRED_PATH: ${{ steps.find_submission.outputs.prediction }}
          META_PATH: ${{ steps.find_submission.outputs.metadata }}
          HEAD_REPO: ${{ steps.find_submission.outputs.head_repo }}
          HEAD_SHA: ${{ steps.find_submission.outputs.head_sha }}

        run: |
          if [ -z "$PRED_PATH" ] || [ -z "$META_PATH" ] || [ -z "$HEAD_REPO" ] || [ -z "$HEAD_SHA" ]; then
            echo "Missing PR submission metadata"
            exit 1
          fi
          # Validate paths
          case "$PRED_PATH" in
            submissions/inbox/*/*/predictions.csv.gpg) ;;
            *) echo "Invalid submission path: $PRED_PATH"; exit 1 ;;
          esac
          case "$META_PATH" in
            submissions/inbox/*/*/metadata.json) ;;
            *) echo "Invalid metadata path: $META_PATH"; exit 1 ;;
          esac
          PRED_URL="https://raw.githubusercontent.com/${HEAD_REPO}/${HEAD_SHA}/${PRED_PATH}"
          META_URL="https://raw.githubusercontent.com/${HEAD_REPO}/${HEAD_SHA}/${META_PATH}"
          curl -fsSL "$PRED_URL" -o /tmp/pr_predictions.csv.gpg
          curl -fsSL "$META_URL" -o /tmp/pr_metadata.json


      # -------------------------------
      # Import private GPG key
      # -------------------------------
      - name: Import private key
        env:
          PRIVATE_KEY: ${{ secrets.COMPETITION_PRIVATE_KEY }}
        run: |
          echo "$PRIVATE_KEY" > /tmp/private.key
          gpg --batch --import /tmp/private.key

      # -------------------------------
      # Decrypt the submission
      # -------------------------------
      - name: Decrypt submission
        run: |
          gpg --batch --yes \
              --output /tmp/pr_predictions.csv \
              --decrypt /tmp/pr_predictions.csv.gpg

      # -------------------------------
      # Validate decrypted CSV format
      # -------------------------------
      - name: Validate submission format
        run: |
          python competition/validate_submission.py /tmp/pr_predictions.csv


      # -------------------------------
      # Run scoring script
      # -------------------------------
      - name: Run scoring script
        id: score
        run: |
          METRICS=$(python competition/scoring_script.py /tmp/pr_predictions.csv data/test_labels.csv)
          echo "metrics=$METRICS" >> $GITHUB_OUTPUT
        continue-on-error: true


      # -------------------------------
      # Comment metrics on PR
      # -------------------------------
      - name: Extract metrics and comment
        if: steps.score.outcome == 'success'
        uses: actions/github-script@v6
        with:
          script: |
            const metrics = JSON.parse(`${{ steps.score.outputs.metrics }}`);
            let message = "## üèÜ Submission Scored\n\n";
            for (const [key, value] of Object.entries(metrics)) {
              message += `**${key}**: ${value}\n`;
            }
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: message
            });


      # -------------------------------
      # Update leaderboard
      # -------------------------------
      - name: Update leaderboard
        if: github.event_name == 'pull_request_target'  && steps.score.outcome == 'success'
        env:
          TEAM: ${{ steps.find_submission.outputs.team }}
          RUN_ID: ${{ steps.find_submission.outputs.run_id }}
        run: |
          MODEL=$(jq -r '.model' /tmp/pr_metadata.json)
          TYPE=$(jq -r '.type' /tmp/pr_metadata.json)
          F1=$(echo '${{ steps.score.outputs.metrics }}' | jq -r '.f1')
          ACC=$(echo '${{ steps.score.outputs.metrics }}' | jq -r '.accuracy')
          python competition/update_leaderboard.py \
            --team "$TEAM" \
            --run "$RUN_ID" \
            --model "$MODEL" \
            --type "$TYPE" \
            --f1 "$F1" \
            --accuracy "$ACC"

     
      # -------------------------------
      # Commit leaderboard update
      # -------------------------------
      - name: Commit leaderboard update
        if: github.event_name == 'pull_request_target' 
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add docs/leaderboard.csv
          git commit -m "Update leaderboard with new submission" || true
          git push

      # -------------------------------
      # Cleanup
      # -------------------------------
      - name: Cleanup
        if: always()
        run: |
          rm -f data/test_labels.csv
          rm -f /tmp/pr_predictions.csv
          rm -f /tmp/pr_predictions.csv.gpg
          rm -f /tmp/private.key

     